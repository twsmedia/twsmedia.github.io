<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Season Tracker (Fixed UTC Offset + Manual DST + AM/PM)</title>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.5; font-size: 18px; margin: 0; }
    h2 { margin: 0 0 8px; }
    .note { color:#555; margin-bottom: 12px; font-size: 14px; }
    .row { display:flex; flex-wrap: wrap; gap: 12px; align-items: center; margin: 10px 0; }
    label { font-size: 16px; }
    input[type="text"], input[type="datetime-local"], button, select { font-size: 16px; padding: 6px 8px; }
    #seasonProgress { margin: 10px 0; }
    #seasonTimes { margin: 8px 0 14px; }
    #milestones { font-size: 16px; margin-bottom: 16px; }
    .divider { height: 1px; background: #e4e4e4; margin: 18px 0; }
    .preset-section { background: #f0f8ff; padding: 12px; border-radius: 4px; margin: 10px 0; }
    .preset-buttons { display: flex; gap: 8px; margin: 8px 0; flex-wrap: wrap; }
    .preset-btn { background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; }
    .preset-btn:hover { background: #45a049; }
    .save-preset { background: #2196F3; }
    .save-preset:hover { background: #1976D2; }
    .delete-preset { background: #f44336; }
    .delete-preset:hover { background: #d32f2f; }
    input[type="text"].preset-name { width: 200px; }

    /* small helper style */
    .inline { display: inline-flex; align-items: center; gap: 10px; }
  
    details { margin-top: 8px; }
    summary { cursor: pointer; }
    .muted { color: gray; font-size: 14px; }
</style>
</head>
<body>
  <div class="navbar">
  <a href="index.html">üè† Home</a>
  <a href="custom.html">Standard Version Only)</a>
  <a href="custom-dst.html">Daylight Saving Time and AM/PM Support Version (this version)</a>
</div>
  <h2>Custom Season Tracker</h2>
  <div id="tzNote" class="note"></div>

  <!-- Preset Section -->
  <div class="preset-section">
    <strong>üîñ Saved Presets:</strong>
    <div id="presetButtons" class="preset-buttons"></div>
    <div class="row" style="margin-top: 12px;">
      <input type="text" id="presetName" class="preset-name" placeholder="Enter preset name (e.g., 'Fall Reading')">
      <button id="savePresetBtn" class="preset-btn save-preset">Save Current Settings as Preset</button>
    </div>
    <div class="note">Save your current settings as a preset, then use the buttons above to quickly switch between different trackers.</div>
  </div>

  <!-- Settings -->
  <div class="row">
    <label for="seasonName">Label (optional):</label>
    <input id="seasonName" type="text" placeholder="e.g., 'Fall Reading Challenge'">
  </div>

  <div class="row">
    <label for="startDT">Start:</label>
    <input id="startDT" type="datetime-local" step="1" />
    <label for="endDT">End:</label>
    <input id="endDT" type="datetime-local" step="1" />
  </div>

  <div class="row">
    <label for="utcOffset">Custom UTC offset (no DST):</label>
    <input id="utcOffset" type="text" placeholder="Examples: 0, -5.5, +05:30">
    <button id="applyBtn">Apply / Save</button>
    <span id="offsetStatus" class="note"></span>
  </div>

  <div class="divider"></div>

  <!-- Output -->
  <div id="seasonHeading"></div>
  <div id="seasonProgress"></div>
  <div id="seasonTimes" class="note"></div>

  <!-- Seconds + countdown -->
  <div id="secondsLine"></div>
  <div id="countdown" style="font-size:18px; font-weight:bold; margin-bottom:12px;"></div>

  <div id="milestones"></div>
  <div id="currentTime" class="note"></div>

  <div class="divider"></div>

  <!-- Display Options -->
  <div id="displayOptions">
    <h3>Display Options</h3>
    <div class="row">
      <label for="pctPlaces">Decimal places:</label>
      <select id="pctPlaces" title="How many places after the decimal to show">
        <option>0</option><option>1</option><option selected>2</option><option>3</option><option>4</option><option>5</option><option>6</option>
      </select>

      <span class="inline" role="group" aria-label="Rounding mode">
        <label><input type="radio" name="pctMode" value="round" checked> Round</label>
        <label><input type="radio" name="pctMode" value="truncate"> Truncate (floor)</label>
      </span>
    </div>
  
    <div class="row">
      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="toggleAmpm">
        Show times in AM/PM (12-hour)
      </label>

      <label style="display:flex; align-items:center; gap:8px;">
        <input type="checkbox" id="toggleDstInterval">
        Apply DST interval (manual)
      </label>
    </div>

    <details id="dstDetails">
      <summary><strong>Manual DST interval settings</strong> <span id="dstStatus" class="muted"></span></summary>

      <div class="row" style="margin-top: 10px;">
        <label for="dstStart">DST start (STANDARD time):</label>
        <input id="dstStart" type="datetime-local" step="1" />
        <label for="dstEnd">DST end (STANDARD time):</label>
        <input id="dstEnd" type="datetime-local" step="1" />
      </div>

      <div class="row">
        <label for="dstShift">DST shift minutes:</label>
        <input id="dstShift" type="number" value="60" step="1" />
        <span class="inline">
          <button id="saveDstInterval">Save DST interval</button>
          <button id="clearDstInterval">Clear saved DST</button>
        </span>
      </div>

      <div class="note">
        This is <strong>display-only</strong>. You enter the start/end in your <strong>standard-time clock</strong>
        for this fixed offset, then (if enabled) the tracker will add the shift (usually 60 minutes) to any times that fall inside the interval.
        <br><br>
        Example (USA 2026): start <strong>2026-03-08 02:00</strong>, end <strong>2026-11-01 01:00</strong>, shift <strong>60</strong> minutes.
      </div>
    </details>
</div>

  <script>
    (function () {
      const { DateTime, FixedOffsetZone } = luxon;

      // --- Time display toggles (AM/PM + manual DST interval) ---
      const AMPM_KEY = "customSeason_ampm";
      const DST_TOGGLE_KEY = "customSeason_manualDstEnabled";
      const DST_CFG_KEY = "customSeason_manualDstConfig";

      function getTimePrefs() {
        const ampm = (localStorage.getItem(AMPM_KEY) === "true");
        const dstOn = (localStorage.getItem(DST_TOGGLE_KEY) === "true");
        let cfg = null;
        try {
          const raw = localStorage.getItem(DST_CFG_KEY);
          if (raw) cfg = JSON.parse(raw);
        } catch {}
        if (cfg && (!cfg.startISO || !cfg.endISO)) cfg = null;
        if (cfg && (cfg.shiftMinutes == null || cfg.shiftMinutes === "")) cfg.shiftMinutes = 60;
        return { ampm, dstOn, cfg };
      }

      function formatDTForUI(dt, zoneLabel, ampm) {
        if (!dt || !dt.isValid) return "‚Äî";
        if (ampm) {
          const s = dt.toFormat("EEE, MMM d, yyyy, h:mm:ssa");
          return s.replace("AM", "am").replace("PM", "pm") + ` ${zoneLabel}`;
        }
        return dt.toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;
      }

      // Display-only manual DST: user enters start/end in STANDARD time for this fixed offset.
      // If dt falls within [start,end), add shiftMinutes (usually 60) for display.
      function applyManualDstIfNeeded(dtInDisplayZone, cachedLabel, prefs) {
        if (!prefs?.dstOn || !prefs?.cfg) return { dt: dtInDisplayZone, isDst: false };

        // If the fixed offset is UTC, do not apply DST (keeps UTC clean)
        if ((cachedLabel || "").toUpperCase() === "UTC") return { dt: dtInDisplayZone, isDst: false };

        const zone = dtInDisplayZone.zoneName; // fixed offset zone
        const start = DateTime.fromISO(prefs.cfg.startISO, { zone });
        const end = DateTime.fromISO(prefs.cfg.endISO, { zone });
        if (!start.isValid || !end.isValid) return { dt: dtInDisplayZone, isDst: false };

        const a = start <= end ? start : end;
        const b = start <= end ? end : start;

        const inInterval = dtInDisplayZone >= a && dtInDisplayZone < b;
        if (!inInterval) return { dt: dtInDisplayZone, isDst: false };

        const shift = Number(prefs.cfg.shiftMinutes ?? 60);
        if (!Number.isFinite(shift)) return { dt: dtInDisplayZone, isDst: false };

        return { dt: dtInDisplayZone.plus({ minutes: shift }), isDst: true };
      }


      function $(id){ return document.getElementById(id); }

      // --- Utilities for fixed offset handling (no DST) ---
      function minutesToSignedHHMM(mins){
        const sign = mins < 0 ? "-" : "+";
        const a = Math.abs(mins);
        const hh = String(Math.floor(a/60)).padStart(2,"0");
        const mm = String(a % 60).padStart(2,"0");
        return sign + hh + ":" + mm;
      }
      function zonePrettyLabel(mins){
        if (mins == null) return "UTC";
        const a = Math.abs(mins), sign = mins < 0 ? "-" : "+";
        const hh = Math.floor(a/60), mm = a % 60;
        return mm === 0 ? `UTC${sign}${hh}` : `UTC${minutesToSignedHHMM(mins)}`;
      }
      function parseOffsetToMinutes(s){
        if (!s) return null;
        s = s.trim();
        if (/^[+-]?\d+(\.\d+)?$/.test(s)) return Math.round(parseFloat(s)*60);
        const m = s.match(/^([+-])(\d{1,2}):([0-5]\d)$/);
        if (m){
          const sign = m[1] === "-" ? -1 : 1;
          const hh = parseInt(m[2],10), mm = parseInt(m[3],10);
          return sign*(hh*60+mm);
        }
        return null;
      }

      // --- Storage keys ---
      const LS = {
        NAME: "customSeason_name",
        START: "customSeason_start",
        END: "customSeason_end",
        OFFSET: "customSeason_offset",
        PRESETS: "customSeason_presets",
        // Bottom display options
        PCT_PLACES: "customSeason_pctPlaces",
        PCT_MODE: "customSeason_pctMode"
      };

      // --- Preset management ---
      function getPresets() {
        const saved = localStorage.getItem(LS.PRESETS);
        return saved ? JSON.parse(saved) : {};
      }
      function savePresets(presets) {
        localStorage.setItem(LS.PRESETS, JSON.stringify(presets));
      }
      function saveCurrentAsPreset(name) {
        if (!name.trim()) {
          alert("Please enter a name for the preset.");
          return;
        }
        const presets = getPresets();
        presets[name] = {
          name: nameInput.value.trim(),
          start: startInput.value,
          end: endInput.value,
          offset: offsetInput.value.trim()
        };
        savePresets(presets);
        renderPresetButtons();
        $("presetName").value = "";
      }
      function loadPreset(presetName) {
        const presets = getPresets();
        const preset = presets[presetName];
        if (!preset) return;

        nameInput.value = preset.name || "";
        startInput.value = preset.start || "";
        endInput.value = preset.end || "";
        offsetInput.value = preset.offset || "";

        applySettings();
      }
      function deletePreset(presetName) {
        if (!confirm(`Delete preset "${presetName}"?`)) return;
        const presets = getPresets();
        delete presets[presetName];
        savePresets(presets);
        renderPresetButtons();
      }
      function renderPresetButtons() {
        const container = $("presetButtons");
        const presets = getPresets();

        container.innerHTML = "";

        if (Object.keys(presets).length === 0) {
          container.innerHTML = '<div class="note">No saved presets yet. Save your first preset below!</div>';
          return;
        }

        for (const [name, preset] of Object.entries(presets)) {
          const btn = document.createElement("button");
          btn.className = "preset-btn";
          btn.textContent = name;
          btn.onclick = () => loadPreset(name);
          container.appendChild(btn);

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "preset-btn delete-preset";
          deleteBtn.textContent = "√ó";
          deleteBtn.title = `Delete "${name}"`;
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deletePreset(name);
          };
          container.appendChild(deleteBtn);
        }
      }

      // --- Milestones ---
      const milestones = [
        { label: "10%", value: 0.10 },
        { label: "20%", value: 0.20 },
        { label: "25%", value: 0.25 },
        { label: "30%", value: 0.30 },
        { label: "‚Öì",  value: 1/3   },
        { label: "40%", value: 0.40 },
        { label: "50%", value: 0.50 },
        { label: "60%", value: 0.60 },
        { label: "‚Öî",  value: 2/3   },
        { label: "70%", value: 0.70 },
        { label: "75%", value: 0.75 },
        { label: "80%", value: 0.80 },
        { label: "90%", value: 0.90 }
      ];

      // --- Elements ---
      const nameInput = $("seasonName");
      const startInput = $("startDT");
      const endInput = $("endDT");
      const offsetInput = $("utcOffset");
      const applyBtn = $("applyBtn");
      const presetNameInput = $("presetName");
      const savePresetBtn = $("savePresetBtn");

      // Bottom controls
      const pctPlacesSel = $("pctPlaces");
      const pctModeRadios = () => [...document.querySelectorAll('input[name="pctMode"]')];

      // Dynamic display elements
      const secondsLineEl = $("secondsLine");
      const countdownEl = $("countdown");
      const milestonesEl = $("milestones");
      const seasonHeadingEl = $("seasonHeading");
      const seasonProgressEl = $("seasonProgress");
      const seasonTimesEl = $("seasonTimes");
      const currentTimeEl = $("currentTime");

      // Cached static state
      let cachedZone = FixedOffsetZone.utcInstance;
      let cachedLabel = "UTC";
      let cachedStartDT = null;
      let cachedEndDT = null;

      // BEST FIX: use integer seconds derived from millisecond endpoints
      let cachedStartMs = 0;
      let cachedEndMs = 0;
      let cachedTotalSecondsInt = 0;

      // --- Load values from localStorage ---
      function loadFromLocalStorage(){
        const name = localStorage.getItem(LS.NAME) || "";
        const startV = localStorage.getItem(LS.START) || "";
        const endV = localStorage.getItem(LS.END) || "";
        const off = localStorage.getItem(LS.OFFSET) || "";

        const places = localStorage.getItem(LS.PCT_PLACES);
        const mode = localStorage.getItem(LS.PCT_MODE);

        nameInput.value = name;
        startInput.value = startV;
        endInput.value = endV;
        offsetInput.value = off;

        if (places !== null) pctPlacesSel.value = String(places);
        if (mode) {
          const radio = pctModeRadios().find(r => r.value === mode);
          if (radio) radio.checked = true;
        }
      }

      // --- Zone helpers ---
      function getUserFixedZone(){
        const saved = localStorage.getItem(LS.OFFSET);
        const mins = parseOffsetToMinutes(saved);
        if (mins === null) return { zone: FixedOffsetZone.utcInstance, mins: 0, label: "UTC" };
        return { zone: FixedOffsetZone.instance(mins), mins, label: zonePrettyLabel(mins) };
      }
      function setOffsetStatus(){
        const saved = localStorage.getItem(LS.OFFSET);
        const mins = parseOffsetToMinutes(saved);
        $("offsetStatus").textContent = mins === null
          ? " (Times show in UTC by default; enter an offset to change.)"
          : " (" + zonePrettyLabel(mins) + ")";
      }

      // --- Parse datetime-local input into Luxon DT in the chosen fixed zone ---
      function parseLocalInputToZoneDT(value, zone){
        if (!value) return null;
        const m = value.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (!m) return null;
        const [ , Y, Mo, D, H, Mi, S ] = m;
        return DateTime.fromObject(
          {
            year: +Y, month: +Mo, day: +D,
            hour: +H, minute: +Mi, second: S ? +S : 0, millisecond: 0
          },
          { zone }
        );
      }

      // --- Percent formatter (round vs truncate) ---
      function formatPercent(pct, places, mode){
        const val = Math.min(100, Math.max(0, pct));
        const factor = 10 ** places;

        let out;
        if (mode === "truncate") {
          out = Math.trunc(val * factor) / factor;
        } else {
          out = Math.round(val * factor) / factor;
        }
        return out.toFixed(places) + "%";
      }

      // --- Round-mode near-100% handling to avoid displaying 100% early ---
      function nearHundredThreshold(places){
        return 100 - 0.5 * Math.pow(10, -places);
      }
      function nearHundredMessage(places){
        const t = nearHundredThreshold(places);
        return `greater than ${t.toFixed(places + 1)}% complete.`;
      }

      // Helper: get current percent display settings
      function getPercentPrefs() {
        const places = parseInt(localStorage.getItem(LS.PCT_PLACES) ?? pctPlacesSel.value, 10) || 0;
        const mode = localStorage.getItem(LS.PCT_MODE) || (pctModeRadios().find(r => r.checked) || {value:"round"}).value;
        return { places, mode };
      }

      // --- Recompute static layout (no per-second stuff here) ---
      function recomputeStatic() {
        const zInfo = getUserFixedZone();
        cachedZone = zInfo.zone;
        cachedLabel = zInfo.label;

        $("tzNote").textContent = `This tracker uses a fixed offset: ${cachedLabel}. You can optionally apply a manual DST interval for display.`;

        const nm = nameInput.value.trim();
        const headingName = nm ? nm : "Custom Season";
        seasonHeadingEl.innerHTML = `<strong>${headingName}</strong>`;

        const startDT = parseLocalInputToZoneDT(startInput.value, cachedZone);
        const endDT   = parseLocalInputToZoneDT(endInput.value, cachedZone);

        cachedStartDT = null;
        cachedEndDT = null;
        cachedStartMs = 0;
        cachedEndMs = 0;
        cachedTotalSecondsInt = 0;

        const fmt = "EEE, MMM d, yyyy, HH:mm:ss";

        if (!startDT || !endDT){
          seasonTimesEl.textContent = "";
          milestonesEl.innerHTML = "";
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          seasonProgressEl.textContent = "Enter a valid start and end date-time, then press Apply / Save.";
          return;
        }

        if (endDT <= startDT){
          seasonTimesEl.textContent = "";
          milestonesEl.innerHTML = "";
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          seasonProgressEl.textContent = "End must be after Start.";
          return;
        }

        cachedStartDT = startDT;
        cachedEndDT = endDT;

        // BEST FIX: derive totals from millisecond endpoints, keep integer seconds
        cachedStartMs = cachedStartDT.toMillis();
        cachedEndMs = cachedEndDT.toMillis();
        cachedTotalSecondsInt = Math.round((cachedEndMs - cachedStartMs) / 1000);

                const prefs = getTimePrefs();

        const startDisp = applyManualDstIfNeeded(startDT, cachedLabel, prefs);
        const endDisp   = applyManualDstIfNeeded(endDT, cachedLabel, prefs);

        const startStr = formatDTForUI(startDisp.dt, cachedLabel, prefs.ampm) + (startDisp.isDst ? " (DST)" : "");
        const endStr   = formatDTForUI(endDisp.dt, cachedLabel, prefs.ampm) + (endDisp.isDst ? " (DST)" : "");

        seasonTimesEl.innerHTML =
          `Start: <strong>${startStr}</strong><br>` +
          `End: <strong>${endStr}</strong`;

                const prefs2 = getTimePrefs();

        let html = `<h3>Milestone Dates (${cachedLabel}):</h3><ul>`;
        for (const m of milestones){
          const dtBase = startDT.plus({ seconds: cachedTotalSecondsInt * m.value });
          const dtDisp = applyManualDstIfNeeded(dtBase, cachedLabel, prefs2);
          const dtStr = formatDTForUI(dtDisp.dt, cachedLabel, prefs2.ampm) + (dtDisp.isDst ? " (DST)" : "");
          html += `<li>${m.label} complete: <strong>${dtStr}</strong></li>`;
        }
        html += `</ul>`;
        milestonesEl.innerHTML = html;
      }

      // --- Apply settings (save to localStorage and recompute static) ---
      function applySettings() {
        const val = offsetInput.value.trim();
        const mins = parseOffsetToMinutes(val);
        if (val !== "" && mins === null) {
          alert("Please enter a valid UTC offset (e.g., 0, 1, -5.5, +05:30), or leave blank for UTC.");
          return;
        }

        localStorage.setItem(LS.NAME, nameInput.value.trim());
        localStorage.setItem(LS.START, startInput.value);
        localStorage.setItem(LS.END, endInput.value);
        localStorage.setItem(LS.OFFSET, val);

        const { places, mode } = getPercentPrefs();
        localStorage.setItem(LS.PCT_PLACES, String(places));
        localStorage.setItem(LS.PCT_MODE, mode);

        setOffsetStatus();
        recomputeStatic();
        tick();
      }

      // --- Dynamic per-second update ---
      function formatCountdown(seconds) {
        if (seconds < 0) seconds = 0;
        const days = Math.floor(seconds / 86400);
        const hrs = Math.floor((seconds % 86400) / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        if (days >= 1) {
          return `${days}d ${hrs.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
        } else {
          const totalHrs = Math.floor(seconds / 3600);
          return `${totalHrs}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
        }
      }

      function tick() {
        if (!cachedStartDT || !cachedEndDT || cachedTotalSecondsInt <= 0) {
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          return;
        }

        const { places, mode } = getPercentPrefs();

        const now = DateTime.now().setZone(cachedZone);
        const nowMs = now.toMillis();

        // BEST FIX: derive BOTH elapsed and remaining from the same integer-second clock
        const elapsedInt = Math.floor((nowMs - cachedStartMs) / 1000);
        const clampedElapsedInt = Math.max(0, Math.min(cachedTotalSecondsInt, elapsedInt));
        const remainingInt = Math.max(0, cachedTotalSecondsInt - clampedElapsedInt);

        const pct = Math.max(0, Math.min(100, (clampedElapsedInt / cachedTotalSecondsInt) * 100));

        let progressText = "";
        if (nowMs < cachedStartMs){
          progressText = "This season hasn't started yet.";
        } else if (nowMs >= cachedEndMs){
          progressText = `This season has ended (${formatPercent(100, places, mode)} complete).`;
        } else {
          if (mode === "round") {
            const threshold = nearHundredThreshold(places);
            if (pct >= threshold && pct < 100) {
              progressText = `This season is ${nearHundredMessage(places)}`;
            } else {
              progressText = `This season is ${formatPercent(pct, places, mode)} complete.`;
            }
          } else {
            progressText = `This season is ${formatPercent(pct, places, mode)} complete.`;
          }
        }
        seasonProgressEl.textContent = progressText;

        // Seconds line (locked to countdown)
        secondsLineEl.textContent =
          `${clampedElapsedInt.toLocaleString()} seconds have passed out of ${cachedTotalSecondsInt.toLocaleString()}.`;

        // Current time
        const fmt = "EEE, MMM d, yyyy, HH:mm:ss";
                const prefs3 = getTimePrefs();
        const nowDisp = applyManualDstIfNeeded(now, cachedLabel, prefs3);
        const nowStr = formatDTForUI(nowDisp.dt, cachedLabel, prefs3.ampm) + (nowDisp.isDst ? " (DST)" : "");
        currentTimeEl.textContent = `‚è± Current time: ${nowStr}`;

        // Countdown (locked to seconds line)
        if (nowMs >= cachedEndMs) {
          countdownEl.textContent = "‚è≥ Countdown: 00:00:00 (season ended)";
        } else {
          countdownEl.textContent = "‚è≥ Countdown: " + formatCountdown(remainingInt);
        }
      }

      // --- Event handlers ---
      applyBtn.addEventListener("click", applySettings);

      savePresetBtn.addEventListener("click", () => {
        saveCurrentAsPreset(presetNameInput.value.trim());
      });

      presetNameInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          saveCurrentAsPreset(presetNameInput.value.trim());
        }
      });

      $("pctPlaces").addEventListener("change", () => {
        localStorage.setItem(LS.PCT_PLACES, String(parseInt(pctPlacesSel.value,10)||0));
        tick();
      });

      pctModeRadios().forEach(r => r.addEventListener("change", () => {
        localStorage.setItem(LS.PCT_MODE, r.value);
        tick();
      }));
      // --- AM/PM + Manual DST controls ---
      const toggleAmpm = $("toggleAmpm");
      const toggleDst = $("toggleDstInterval");
      const dstStartInput = $("dstStart");
      const dstEndInput = $("dstEnd");
      const dstShiftInput = $("dstShift");
      const saveDstIntervalBtn = $("saveDstInterval");
      const clearDstIntervalBtn = $("clearDstInterval");
      const dstStatus = $("dstStatus");

      if (toggleAmpm) {
        toggleAmpm.checked = (localStorage.getItem(AMPM_KEY) === "true");
        toggleAmpm.addEventListener("change", () => {
          localStorage.setItem(AMPM_KEY, toggleAmpm.checked ? "true" : "false");
          // Rebuild static displays so all timestamps change format
          recomputeStatic();
          tick();
        });
      }

      if (toggleDst) {
        toggleDst.checked = (localStorage.getItem(DST_TOGGLE_KEY) === "true");
        toggleDst.addEventListener("change", () => {
          localStorage.setItem(DST_TOGGLE_KEY, toggleDst.checked ? "true" : "false");
          recomputeStatic();
          tick();
        });
      }

      // Load saved DST config into inputs
      try {
        const raw = localStorage.getItem(DST_CFG_KEY);
        if (raw && dstStartInput && dstEndInput && dstShiftInput) {
          const cfg = JSON.parse(raw);
          if (cfg?.startISO) dstStartInput.value = String(cfg.startISO).slice(0, 19);
          if (cfg?.endISO) dstEndInput.value = String(cfg.endISO).slice(0, 19);
          if (cfg?.shiftMinutes != null) dstShiftInput.value = String(cfg.shiftMinutes);
          if (dstStatus) dstStatus.textContent = "(Loaded saved DST interval)";
        }
      } catch {}

      if (saveDstIntervalBtn) {
        saveDstIntervalBtn.addEventListener("click", () => {
          if (!dstStartInput.value || !dstEndInput.value) {
            alert("Please enter both DST start and DST end (in standard time).");
            return;
          }
          const shift = parseInt(String(dstShiftInput.value || "").trim(), 10);
          if (!Number.isFinite(shift)) {
            alert("Please enter a valid DST shift minutes value (usually 60).");
            return;
          }
          const cfg = { startISO: dstStartInput.value.trim(), endISO: dstEndInput.value.trim(), shiftMinutes: shift };
          localStorage.setItem(DST_CFG_KEY, JSON.stringify(cfg));
          if (dstStatus) dstStatus.textContent = "(Saved)";
          recomputeStatic();
          tick();
        });
      }

      if (clearDstIntervalBtn) {
        clearDstIntervalBtn.addEventListener("click", () => {
          localStorage.removeItem(DST_CFG_KEY);
          if (dstStartInput) dstStartInput.value = "";
          if (dstEndInput) dstEndInput.value = "";
          if (dstShiftInput) dstShiftInput.value = "60";
          if (dstStatus) dstStatus.textContent = "(Cleared)";
          recomputeStatic();
          tick();
        });
      }


      // --- Init ---
      loadFromLocalStorage();
      setOffsetStatus();
      renderPresetButtons();
      recomputeStatic();
      tick();

      // You can keep 100ms; the displayed integers are stable and consistent.
      setInterval(tick, 100);

    })();
  </script>
</body>
</html>
