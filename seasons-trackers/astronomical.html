<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Season Progress Tracker (auto seasons + UTC display + hemisphere + user UTC offset)</title>

  <!-- Luxon (time handling) -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>

  <!-- Astronomy Engine (equinoxes/solstices) -->
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine/astronomy.browser.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.5; font-size: 18px; }
    .note { color:#555; margin-bottom: 16px; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom: 12px; flex-wrap: wrap; }
    input[type="text"], input[type="number"], select { padding:6px 8px; font-size:16px; }
    button { padding:6px 10px; font-size:16px; cursor:pointer; }
    ul { margin-top: 8px; }
    h3 { margin: 14px 0 8px; }
    #seasonHeading { font-size: 20px; margin: 8px 0 6px; }
    .divider { height: 1px; background: #e4e4e4; margin: 18px 0; }
    .btn-group { display:flex; gap:8px; flex-wrap: wrap; }
  </style>
</head>
<body>

  <!-- TOP content -->
  <div id="seasonHeading"></div>
  <div id="seasonProgress" style="margin-bottom: 10px;"></div>
  <div id="seasonTimes" class="note"></div>
  <div id="milestones" style="font-size: 16px; margin-bottom: 20px;"></div>
  <div id="currentTime" style="font-size: 14px; color: gray;"></div>

  <div class="divider"></div>

  <!-- Controls -->
  <div class="note">All season boundary timestamps below are shown in <strong>UTC</strong>. Milestones use your entered offset.</div>
  <div class="row">
    <label for="hemisphere">Hemisphere:</label>
    <select id="hemisphere" title="Choose hemisphere">
      <option value="auto">Auto (by time zone)</option>
      <option value="north">Northern Hemisphere</option>
      <option value="south">Southern Hemisphere</option>
    </select>

    <label for="utcOffset">Your UTC offset (no DST):</label>
    <input id="utcOffset" type="text" placeholder="Examples: 1, -5.5, +05:30" />
    <button id="applyOffset">Apply</button>
    <span id="offsetStatus" class="note"></span>
  </div>

  <div class="row btn-group">
    <button id="useStd" title="Set to your local Standard Time fixed offset (e.g., New York = UTC-5)">Use Local Standard Time</button>
    <button id="useDst" title="Set to your local Daylight Saving Time fixed offset (e.g., New York = UTC-4)">Use Local Daylight Time</button>
  </div>

  <div class="divider"></div>

  <!-- NEW: Percentage formatting controls -->
  <div class="row">
    <label for="pctMethod">Percentage method:</label>
    <select id="pctMethod" title="Choose how to format the percentage">
      <option value="truncate">Truncate (floor)</option>
      <option value="round">Round</option>
    </select>

    <label for="pctDecimals">Decimal places:</label>
    <input id="pctDecimals" type="number" min="0" max="10" value="2" style="width: 70px;" />
    <button id="applyPctSettings">Apply</button>
  </div>

  <script>
    const { DateTime, FixedOffsetZone } = luxon;

    // ===== Milestones (unchanged) =====
    const milestones = [
      { label: "10%", value: 0.10 },
      { label: "20%", value: 0.20 },
      { label: "25%", value: 0.25 },
      { label: "30%", value: 0.30 },
      { label: "‚Öì",  value: 1/3   },
      { label: "40%", value: 0.40 },
      { label: "50%", value: 0.50 },
      { label: "60%", value: 0.60 },
      { label: "‚Öî",  value: 2/3   },
      { label: "70%", value: 0.70 },
      { label: "75%", value: 0.75 },
      { label: "80%", value: 0.80 },
      { label: "90%", value: 0.90 }
    ];

    // ===== NEW: Percentage formatting settings =====
    const PCT_METHOD_KEY = "pctMethod";
    const PCT_DECIMALS_KEY = "pctDecimals";
    const pctMethodSelect = document.getElementById("pctMethod");
    const pctDecimalsInput = document.getElementById("pctDecimals");
    const applyPctBtn = document.getElementById("applyPctSettings");

    function getPctSettings() {
      const method = localStorage.getItem(PCT_METHOD_KEY) || "truncate";
      const decimals = parseInt(localStorage.getItem(PCT_DECIMALS_KEY) || "2", 10);
      return { method, decimals };
    }

    function formatPercentage(rawPct) {
      const { method, decimals } = getPctSettings();
      const multiplier = Math.pow(10, decimals);
      
      let result;
      if (method === "round") {
        result = Math.round(rawPct * multiplier) / multiplier;
      } else {
        result = Math.floor(rawPct * multiplier) / multiplier;
      }
      
      return result.toFixed(decimals);
    }

    applyPctBtn.addEventListener("click", () => {
      const decimals = parseInt(pctDecimalsInput.value, 10);
      if (isNaN(decimals) || decimals < 0 || decimals > 10) {
        alert("Please enter a valid number of decimal places (0-10).");
        return;
      }
      localStorage.setItem(PCT_METHOD_KEY, pctMethodSelect.value);
      localStorage.setItem(PCT_DECIMALS_KEY, decimals.toString());
      updateAll();
    });

    // ===== Hemisphere handling (unchanged) =====
    const hemiSelect = document.getElementById("hemisphere");
    const HEMI_KEY = "seasonHemisphere";
    const hemiEmoji = { north: "üçÇ", south: "üå±" };

    function autoGuessHemisphere() {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || "";
      const southPrefixes = [
        "Australia/", "Pacific/Auckland", "Pacific/Chatham", "Pacific/Easter", "Pacific/Tahiti",
        "America/Argentina", "America/Santiago", "America/Punta_Arenas", "America/Asuncion",
        "America/Montevideo", "America/Sao_Paulo", "America/Cayenne", "Atlantic/South_Georgia",
        "Africa/Johannesburg", "Africa/Windhoek", "Indian/Antananarivo", "Indian/Reunion", "Indian/Mauritius"
      ];
      for (const p of southPrefixes) { if (tz.startsWith(p)) return "south"; }
      return "north";
    }

    function getHemisphere() {
      const saved = localStorage.getItem(HEMI_KEY) || "auto";
      if (saved === "north" || saved === "south") return saved;
      return autoGuessHemisphere();
    }

    // ===== User UTC offset (unchanged) =====
    const offsetInput = document.getElementById("utcOffset");
    const applyBtn = document.getElementById("applyOffset");
    const OFFSET_KEY = "utcOffsetUser";

    function parseOffsetToMinutes(s) {
      if (!s) return null;
      s = s.trim();
      if (/^[+-]?\d+(\.\d+)?$/.test(s)) return Math.round(parseFloat(s) * 60);
      const m = s.match(/^([+-])(\d{1,2}):([0-5]\d)$/);
      if (m) {
        const sign = m[1] === "-" ? -1 : 1;
        const hh = parseInt(m[2], 10);
        const mm = parseInt(m[3], 10);
        return sign * (hh * 60 + mm);
      }
      return null;
    }
    function minutesToSignedHHMM(mins) {
      const sign = mins < 0 ? "-" : "+";
      const a = Math.abs(mins);
      const hh = Math.floor(a / 60).toString().padStart(2, "0");
      const mm = (a % 60).toString().padStart(2, "0");
      return sign + hh + ":" + mm;
    }
    function zonePrettyLabel(mins) {
      if (mins == null) return "UTC";
      const sign = mins < 0 ? "-" : "+";
      const a = Math.abs(mins);
      const hours = Math.floor(a / 60);
      const minutes = a % 60;
      if (minutes === 0) return `UTC${sign}${hours}`;
      return `UTC${minutesToSignedHHMM(mins)}`;
    }
    function getUserFixedZone() {
      const saved = localStorage.getItem(OFFSET_KEY);
      const mins = parseOffsetToMinutes(saved);
      if (mins === null) return null;
      return { zone: luxon.FixedOffsetZone.instance(mins), mins };
    }
    function setUserOffsetDisplay(mins) {
      const status = document.getElementById("offsetStatus");
      if (mins === null) status.textContent = " (Using system clock; enter an offset like 1, -5.5, or +05:30)";
      else status.textContent = " (" + zonePrettyLabel(mins) + ")";
    }
    applyBtn.addEventListener("click", () => {
      const mins = parseOffsetToMinutes(offsetInput.value);
      if (mins === null) { alert("Please enter a valid UTC offset (e.g., 1, -5.5, +05:30)."); return; }
      localStorage.setItem(OFFSET_KEY, offsetInput.value.trim());
      setUserOffsetDisplay(mins);
      updateAll();
    });

    // Local Standard / Daylight convenience buttons
    const useStdBtn = document.getElementById("useStd");
    const useDstBtn = document.getElementById("useDst");
    function getLocalStdDstOffsets(tz) {
      const y = DateTime.now().year;
      const jan = DateTime.fromObject({ year: y, month: 1, day: 15 }, { zone: tz });
      const jul = DateTime.fromObject({ year: y, month: 7, day: 15 }, { zone: tz });
      const janOff = jan.offset, julOff = jul.offset;
      const std = Math.abs(janOff) > Math.abs(julOff) ? janOff : julOff;
      const dst = (std === janOff) ? julOff : janOff;
      return { std, dst };
    }
    function applyFixedOffset(mins) {
      const hhmm = minutesToSignedHHMM(mins);
      localStorage.setItem(OFFSET_KEY, hhmm);
      offsetInput.value = hhmm;
      setUserOffsetDisplay(mins);
      updateAll();
    }
    useStdBtn.addEventListener("click", () => {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const { std } = getLocalStdDstOffsets(tz);
      applyFixedOffset(std);
    });
    useDstBtn.addEventListener("click", () => {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const { dst } = getLocalStdDstOffsets(tz);
      applyFixedOffset(dst);
    });

    // ===== Auto season boundaries via Astronomy Engine =====
    const seasonsCache = new Map();
    function seasonsForYear(y) {
      if (!seasonsCache.has(y)) {
        const s = Astronomy.Seasons(y);
        seasonsCache.set(y, {
          mar: DateTime.fromJSDate(s.mar_equinox.date, { zone: "utc" }),
          jun: DateTime.fromJSDate(s.jun_solstice.date, { zone: "utc" }),
          sep: DateTime.fromJSDate(s.sep_equinox.date, { zone: "utc" }),
          dec: DateTime.fromJSDate(s.dec_solstice.date, { zone: "utc" })
        });
      }
      return seasonsCache.get(y);
    }

    function currentSeasonBounds(nowUTC, hemi) {
      const y = nowUTC.year;
      const cur = seasonsForYear(y);
      const prev = seasonsForYear(y - 1);
      const next = seasonsForYear(y + 1);

      let startUTC, endUTC, index;
      if (nowUTC < cur.mar) {
        startUTC = prev.dec; endUTC = cur.mar; index = 3;
      } else if (nowUTC < cur.jun) {
        startUTC = cur.mar; endUTC = cur.jun; index = 0;
      } else if (nowUTC < cur.sep) {
        startUTC = cur.jun; endUTC = cur.sep; index = 1;
      } else if (nowUTC < cur.dec) {
        startUTC = cur.sep; endUTC = cur.dec; index = 2;
      } else {
        startUTC = cur.dec; endUTC = next.mar; index = 3;
      }

      function labelsFor(index, hemi) {
        const north = [
          { seasonName: "astronomical spring", start: "Spring begins (equinox)", end: "Summer begins (solstice)", emoji: "üå∏" },
          { seasonName: "astronomical summer", start: "Summer begins (solstice)", end: "Autumn begins (equinox)", emoji: "‚òÄÔ∏è" },
          { seasonName: "astronomical autumn", start: "Autumn begins (equinox)", end: "Winter begins (solstice)", emoji: "üçÇ" },
          { seasonName: "astronomical winter", start: "Winter begins (solstice)", end: "Spring begins (equinox)", emoji: "‚ùÑÔ∏è" }
        ];
        const southMap = [2, 3, 0, 1];
        const rec = (hemi === "south") ? north[southMap[index]] : north[index];
        return {
          seasonName: rec.seasonName,
          startLabel: rec.start,
          endLabel: rec.end,
          emoji: (hemi === "south") ? "üå±" : (rec.emoji || "üçÇ")
        };
      }

      return { startUTC, endUTC, index, ...labelsFor(index, hemi) };
    }

    // ===== Renderers (updated to use formatPercentage) =====
    function updateSeasonHeading(bounds) {
      const hemiChoice = (localStorage.getItem(HEMI_KEY) || "auto");
      const hemi = hemiChoice === "auto" ? getHemisphere() : hemiChoice;
      const { seasonName, emoji } = bounds;
      document.getElementById("seasonHeading").textContent =
        `${emoji} Tracking ${seasonName} (${hemi === "south" ? "Southern" : "Northern"} Hemisphere label)`;
    }

    function updateSeasonProgress(bounds) {
      const nowUTC = DateTime.utc();
      const { startUTC, endUTC, seasonName } = bounds;
      const div = document.getElementById("seasonProgress");

      if (nowUTC < startUTC) {
        div.textContent = `The period for ${seasonName} hasn't started yet (based on UTC).`;
      } else if (nowUTC > endUTC) {
        div.textContent = `The period for ${seasonName} has already ended (based on UTC).`;
      } else {
        const totalSeconds = endUTC.diff(startUTC).as("seconds");
        const elapsed = nowUTC.diff(startUTC).as("seconds");
        const rawPct = (elapsed / totalSeconds) * 100;
        const formattedPct = formatPercentage(rawPct);

        let text = `${seasonName.charAt(0).toUpperCase() + seasonName.slice(1)} is ${formattedPct}% complete (UTC).`;

        if (parseFloat(formattedPct) >= 99.99 && nowUTC < endUTC) {
          const remaining = Math.max(0, Math.floor(endUTC.diff(nowUTC, "seconds").seconds));
          const mm = Math.floor(remaining / 60);
          const ss = String(remaining % 60).padStart(2, "0");
          text += `  ‚è≥ ${mm}:${ss} remaining`;
        }
        div.textContent = text;
      }
    }

    function showSeasonTimes(bounds) {
      const { startUTC, endUTC, startLabel, endLabel } = bounds;
      const timesDiv = document.getElementById("seasonTimes");

      const z = getUserFixedZone();
      const displayZone = z ? z.zone : "utc";
      const zoneLabel = z ? zonePrettyLabel(z.mins) : "UTC";

      const startStr = startUTC.setZone(displayZone).toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;
      const endStr   = endUTC.setZone(displayZone).toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;

      timesDiv.innerHTML = `
        ${startLabel}: <strong>${startStr}</strong><br>
        ${endLabel}: <strong>${endStr}</strong>
      `;
    }

    function showMilestoneTimes(bounds) {
      const milestoneDiv = document.getElementById("milestones");
      const { startUTC, endUTC } = bounds;
      const nowUTC = DateTime.utc();

      const totalSeconds = endUTC.diff(startUTC).as("seconds");
      const clampedElapsed = Math.max(0, Math.min(totalSeconds, nowUTC.diff(startUTC).as("seconds")));

      const z = getUserFixedZone();
      const displayZone = z ? z.zone : "utc";
      const zoneLabel = z ? zonePrettyLabel(z.mins) : "UTC";

      let html = `<h3>Milestone Dates (shown in ${zoneLabel}):</h3>`;
      html += `<p><strong>${Math.floor(clampedElapsed).toLocaleString()}</strong> seconds have passed out of <strong>${Math.floor(totalSeconds).toLocaleString()}</strong>.</p>`;
      html += `<ul>`;
      for (const m of milestones) {
        const secondsOffset = totalSeconds * m.value;
        const milestoneDT = startUTC.plus({ seconds: secondsOffset }).setZone(displayZone);
        const label = milestoneDT.toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;
        html += `<li>${m.label} complete: <strong>${label}</strong></li>`;
      }
      html += `</ul>`;
      milestoneDiv.innerHTML = html;
    }

    function updateCurrentTime() {
      const currentDiv = document.getElementById("currentTime");
      const z = getUserFixedZone();

      const nowInUserZone = z ? DateTime.now().setZone(z.zone) : DateTime.now();
      const nowUTC = DateTime.utc();

      const userLabel = z ? zonePrettyLabel(z.mins)
                          : (nowInUserZone.offset === 0 ? "UTC" : `UTC${minutesToSignedHHMM(nowInUserZone.offset)}`);

      currentDiv.textContent =
        `‚è± Current time (your entered offset): ${nowInUserZone.toFormat("EEE, MMM d, yyyy, HH:mm:ss")} (${userLabel})  |  ` +
        `UTC now: ${nowUTC.toFormat("EEE, MMM d, yyyy, HH:mm:ss 'UTC'")}`;
    }

    function updateAll() {
      const hemiChoice = (localStorage.getItem(HEMI_KEY) || "auto");
      const hemi = hemiChoice === "auto" ? getHemisphere() : hemiChoice;
      const nowUTC = DateTime.utc();
      const bounds = currentSeasonBounds(nowUTC, hemi);

      updateSeasonHeading(bounds);
      showSeasonTimes(bounds);
      showMilestoneTimes(bounds);
      updateSeasonProgress(bounds);
      updateCurrentTime();
    }

    // ===== Init =====
    (function initControls() {
      // Hemisphere selector wiring
      const savedHemi = localStorage.getItem(HEMI_KEY) || "auto";
      hemiSelect.value = savedHemi;
      hemiSelect.addEventListener("change", () => {
        const choice = hemiSelect.value;
        localStorage.setItem(HEMI_KEY, choice);
        updateAll();
      });

      // UTC offset
      const savedOffset = localStorage.getItem(OFFSET_KEY);
      if (savedOffset) offsetInput.value = savedOffset;
      const z = getUserFixedZone();
      setUserOffsetDisplay(z ? z.mins : null);

      // Percentage formatting
      const { method, decimals } = getPctSettings();
      pctMethodSelect.value = method;
      pctDecimalsInput.value = decimals;
    })();

    updateAll();
    setInterval(updateAll, 1000);
  </script>
</body>
</html>
