<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Season Progress Tracker (auto seasons + UTC display + hemisphere + user UTC offset)</title>

  <!-- Luxon (time handling) -->
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>

  <!-- Astronomy Engine (equinoxes/solstices) -->
  <script src="https://cdn.jsdelivr.net/npm/astronomy-engine/astronomy.browser.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.5; font-size: 18px; }
    .note { color:#555; margin-bottom: 16px; }
    .row { display:flex; gap:12px; align-items:center; margin-bottom: 12px; flex-wrap: wrap; }
    input[type="text"], select { padding:6px 8px; font-size:16px; }
    button { padding:6px 10px; font-size:16px; cursor:pointer; }
    ul { margin-top: 8px; }
    h3 { margin: 14px 0 8px; }
    #seasonHeading { font-size: 20px; margin: 8px 0 6px; }
    .divider { height: 1px; background: #e4e4e4; margin: 18px 0; }
    .btn-group { display:flex; gap:8px; flex-wrap: wrap; }
  </style>
</head>

<body>
  <div style="margin-bottom: 20px;">
  <a href="index.html">üè† Home</a> |
  <a href="astronomical.html">Standard Time Only Version (this page)</a> |
  <a href="astronomical-dst.html">Daylight Saving Time Support Version</a>
</div>


  <!-- TOP content -->
  <div id="seasonHeading"></div>
  <div id="seasonProgress" style="margin-bottom: 10px;"></div>
  <div id="seasonTimes" class="note"></div>
  <div id="milestones" style="font-size: 16px; margin-bottom: 20px;"></div>
  <div id="currentTime" style="font-size: 14px; color: gray;"></div>

  <div class="divider"></div>

  <!-- Controls -->
  <div class="note">
    All season boundary timestamps below are shown in <strong>UTC</strong>. Milestones use your entered offset.
  </div>

  <div class="row">
    <label for="hemisphere">Hemisphere:</label>
    <select id="hemisphere" title="Choose hemisphere">
      <option value="auto">Auto (by time zone)</option>
      <option value="north">Northern Hemisphere</option>
      <option value="south">Southern Hemisphere</option>
    </select>

    <label for="utcOffset">Your UTC offset (no DST):</label>
    <input id="utcOffset" type="text" placeholder="Examples: 1, -5.5, +05:30" />
    <button id="applyOffset">Apply</button>
    <span id="offsetStatus" class="note"></span>
  </div>

  <div class="row btn-group">
    <button id="useStd" title="Set to your local Standard Time fixed offset (e.g., New York = UTC-5)">
      Use Local Standard Time
    </button>
    <button id="useDst" title="Set to your local Daylight Saving Time fixed offset (e.g., New York = UTC-4)">
      Use Local Daylight Time
    </button>
  </div>

  <!-- Percent display controls (draft#9) -->
  <div class="row">
    <label for="pctMode">Percent mode:</label>
    <select id="pctMode" title="Round or truncate the displayed percentage">
      <option value="truncate">Truncate</option>
      <option value="round">Round</option>
    </select>

    <label for="pctDecimals">Decimal places:</label>
    <select id="pctDecimals" title="How many decimals to show (0‚Äì6)"></select>
  </div>

  <script>
    const { DateTime, FixedOffsetZone } = luxon;

    // =========================
    // draft#9:
    // - Keeps draft#8's "off by one" fix (integer ms) in milestone elapsed + countdown
    // - Adds percent formatting controls: truncate/round + 0..6 decimals
    // - Adds "over 99.5%" / "over 99.95%" messaging near 100% for low decimals
    // =========================

    // ===== Milestones =====
    const milestones = [
      { label: "10%", value: 0.10 },
      { label: "20%", value: 0.20 },
      { label: "25%", value: 0.25 },
      { label: "30%", value: 0.30 },
      { label: "‚Öì",  value: 1 / 3 },
      { label: "40%", value: 0.40 },
      { label: "50%", value: 0.50 },
      { label: "60%", value: 0.60 },
      { label: "‚Öî",  value: 2 / 3 },
      { label: "70%", value: 0.70 },
      { label: "75%", value: 0.75 },
      { label: "80%", value: 0.80 },
      { label: "90%", value: 0.90 }
    ];

    // ===== Hemisphere handling =====
    const hemiSelect = document.getElementById("hemisphere");
    const HEMI_KEY = "seasonHemisphere";
    const hemiEmoji = { north: "üçÇ", south: "üå±" };

    function autoGuessHemisphere() {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone || "";
      const southPrefixes = [
        "Australia/", "Pacific/Auckland", "Pacific/Chatham", "Pacific/Easter", "Pacific/Tahiti",
        "America/Argentina", "America/Santiago", "America/Punta_Arenas", "America/Asuncion",
        "America/Montevideo", "America/Sao_Paulo", "America/Cayenne", "Atlantic/South_Georgia",
        "Africa/Johannesburg", "Africa/Windhoek", "Indian/Antananarivo", "Indian/Reunion", "Indian/Mauritius"
      ];
      for (const p of southPrefixes) {
        if (tz.startsWith(p)) return "south";
      }
      return "north";
    }

    function getHemisphere() {
      const saved = localStorage.getItem(HEMI_KEY) || "auto";
      if (saved === "north" || saved === "south") return saved;
      return autoGuessHemisphere();
    }

    // ===== User UTC offset =====
    const offsetInput = document.getElementById("utcOffset");
    const applyBtn = document.getElementById("applyOffset");
    const OFFSET_KEY = "utcOffsetUser";

    function parseOffsetToMinutes(s) {
      if (!s) return null;
      s = s.trim();

      // examples: 1, -5.5, +3
      if (/^[+-]?\d+(\.\d+)?$/.test(s)) {
        return Math.round(parseFloat(s) * 60);
      }

      // example: +05:30, -04:00
      const m = s.match(/^([+-])(\d{1,2}):([0-5]\d)$/);
      if (m) {
        const sign = m[1] === "-" ? -1 : 1;
        const hh = parseInt(m[2], 10);
        const mm = parseInt(m[3], 10);
        return sign * (hh * 60 + mm);
      }

      return null;
    }

    function minutesToSignedHHMM(mins) {
      const sign = mins < 0 ? "-" : "+";
      const a = Math.abs(mins);
      const hh = Math.floor(a / 60).toString().padStart(2, "0");
      const mm = (a % 60).toString().padStart(2, "0");
      return sign + hh + ":" + mm;
    }

    function zonePrettyLabel(mins) {
      if (mins == null) return "UTC";
      const sign = mins < 0 ? "-" : "+";
      const a = Math.abs(mins);
      const hours = Math.floor(a / 60);
      const minutes = a % 60;
      if (minutes === 0) return `UTC${sign}${hours}`;
      return `UTC${minutesToSignedHHMM(mins)}`;
    }

    function getUserFixedZone() {
      const saved = localStorage.getItem(OFFSET_KEY);
      const mins = parseOffsetToMinutes(saved);
      if (mins === null) return null;
      return { zone: FixedOffsetZone.instance(mins), mins };
    }

    function setUserOffsetDisplay(mins) {
      const status = document.getElementById("offsetStatus");
      if (mins === null) {
        status.textContent = " (Using system clock; enter an offset like 1, -5.5, or +05:30)";
      } else {
        status.textContent = " (" + zonePrettyLabel(mins) + ")";
      }
    }

    applyBtn.addEventListener("click", () => {
      const mins = parseOffsetToMinutes(offsetInput.value);
      if (mins === null) {
        alert("Please enter a valid UTC offset (e.g., 1, -5.5, +05:30).");
        return;
      }
      localStorage.setItem(OFFSET_KEY, offsetInput.value.trim());
      setUserOffsetDisplay(mins);
      updateAll();
    });

    // Local Standard / Daylight convenience buttons
    const useStdBtn = document.getElementById("useStd");
    const useDstBtn = document.getElementById("useDst");

    function getLocalStdDstOffsets(tz) {
      const y = DateTime.now().year;
      const jan = DateTime.fromObject({ year: y, month: 1, day: 15 }, { zone: tz });
      const jul = DateTime.fromObject({ year: y, month: 7, day: 15 }, { zone: tz });
      const janOff = jan.offset;
      const julOff = jul.offset;

      // Standard time tends to have the larger absolute offset (e.g., -300 vs -240)
      const std = Math.abs(janOff) > Math.abs(julOff) ? janOff : julOff;
      const dst = (std === janOff) ? julOff : janOff;
      return { std, dst };
    }

    function applyFixedOffset(mins) {
      const hhmm = minutesToSignedHHMM(mins);
      localStorage.setItem(OFFSET_KEY, hhmm);
      offsetInput.value = hhmm;
      setUserOffsetDisplay(mins);
      updateAll();
    }

    useStdBtn.addEventListener("click", () => {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const { std } = getLocalStdDstOffsets(tz);
      applyFixedOffset(std);
    });

    useDstBtn.addEventListener("click", () => {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const { dst } = getLocalStdDstOffsets(tz);
      applyFixedOffset(dst);
    });

    // ===== Percent display controls (draft#9) =====
    const PCT_MODE_KEY = "pctMode";
    const PCT_DECIMALS_KEY = "pctDecimals";
    const pctModeSelect = document.getElementById("pctMode");
    const pctDecimalsSelect = document.getElementById("pctDecimals");

    // Populate decimal places 0..6
    for (let i = 0; i <= 6; i++) {
      const opt = document.createElement("option");
      opt.value = String(i);
      opt.textContent = String(i);
      pctDecimalsSelect.appendChild(opt);
    }

    // ===== Round season boundaries to nearest minute (seconds still displayed as :00) =====
    function roundToNearestMinute(dt) {
      const sec = dt.second;
      const base = dt.set({ second: 0, millisecond: 0 });
      return sec >= 30 ? base.plus({ minutes: 1 }) : base;
    }

    // ===== Auto season boundaries via Astronomy Engine =====
    const seasonsCache = new Map();

    function seasonsForYear(y) {
      if (!seasonsCache.has(y)) {
        const s = Astronomy.Seasons(y);

        const mar = roundToNearestMinute(DateTime.fromJSDate(s.mar_equinox.date, { zone: "utc" }));
        const jun = roundToNearestMinute(DateTime.fromJSDate(s.jun_solstice.date, { zone: "utc" }));
        const sep = roundToNearestMinute(DateTime.fromJSDate(s.sep_equinox.date, { zone: "utc" }));
        const dec = roundToNearestMinute(DateTime.fromJSDate(s.dec_solstice.date, { zone: "utc" }));

        seasonsCache.set(y, { mar, jun, sep, dec });
      }
      return seasonsCache.get(y);
    }

    // Determine current season interval (as defined for the Northern Hemisphere),
    // then remap labels for Southern Hemisphere as needed.
    function currentSeasonBounds(nowUTC, hemi) {
      const y = nowUTC.year;
      const cur = seasonsForYear(y);
      const prev = seasonsForYear(y - 1);
      const next = seasonsForYear(y + 1);

      let startUTC, endUTC, index;

      // index: 0 spring, 1 summer, 2 autumn, 3 winter (north labels)
      if (nowUTC < cur.mar) {
        startUTC = prev.dec;
        endUTC = cur.mar;
        index = 3;
      } else if (nowUTC < cur.jun) {
        startUTC = cur.mar;
        endUTC = cur.jun;
        index = 0;
      } else if (nowUTC < cur.sep) {
        startUTC = cur.jun;
        endUTC = cur.sep;
        index = 1;
      } else if (nowUTC < cur.dec) {
        startUTC = cur.sep;
        endUTC = cur.dec;
        index = 2;
      } else {
        startUTC = cur.dec;
        endUTC = next.mar;
        index = 3;
      }

      function labelsFor(i, hemisphere) {
        const north = [
          { seasonName: "astronomical spring", start: "Spring begins (equinox)", end: "Summer begins (solstice)", emoji: "üå∏" },
          { seasonName: "astronomical summer", start: "Summer begins (solstice)", end: "Autumn begins (equinox)", emoji: "‚òÄÔ∏è" },
          { seasonName: "astronomical autumn", start: "Autumn begins (equinox)", end: "Winter begins (solstice)", emoji: "üçÇ" },
          { seasonName: "astronomical winter", start: "Winter begins (solstice)", end: "Spring begins (equinox)", emoji: "‚ùÑÔ∏è" }
        ];
        const southMap = [2, 3, 0, 1];
        const rec = (hemisphere === "south") ? north[southMap[i]] : north[i];
        return {
          seasonName: rec.seasonName,
          startLabel: rec.start,
          endLabel: rec.end,
          emoji: (hemisphere === "south") ? "üå±" : (rec.emoji || "üçÇ")
        };
      }

      return { startUTC, endUTC, index, ...labelsFor(index, hemi) };
    }

    // ===== Renderers =====
    function updateSeasonHeading(bounds) {
      const hemiChoice = (localStorage.getItem(HEMI_KEY) || "auto");
      const hemi = hemiChoice === "auto" ? getHemisphere() : hemiChoice;
      const { seasonName, emoji } = bounds;

      document.getElementById("seasonHeading").textContent =
        `${emoji} Tracking ${seasonName} (${hemi === "south" ? "Southern" : "Northern"} Hemisphere label)`;
    }

    function updateSeasonProgress(bounds) {
      const nowUTC = DateTime.utc();
      const { startUTC, endUTC, seasonName } = bounds;
      const div = document.getElementById("seasonProgress");

      if (nowUTC < startUTC) {
        div.textContent = `The period for ${seasonName} hasn't started yet (based on UTC).`;
        return;
      }

      if (nowUTC > endUTC) {
        div.textContent = `The period for ${seasonName} has already ended (based on UTC).`;
        return;
      }

      const totalSeconds = endUTC.diff(startUTC).as("seconds");
      const elapsed = nowUTC.diff(startUTC).as("seconds");
      const rawPct = (elapsed / totalSeconds) * 100;

      const mode = localStorage.getItem(PCT_MODE_KEY) || "truncate";
      const decimals = Math.max(0, Math.min(6, parseInt(localStorage.getItem(PCT_DECIMALS_KEY) || "2", 10)));
      const factor = Math.pow(10, decimals);

      const displayedPct = (mode === "round")
        ? (Math.round(rawPct * factor) / factor)
        : (Math.floor(rawPct * factor) / factor);

      // Threshold: 100 - 0.5 * 10^-decimals
      const near100Threshold = 100 - (0.5 / factor);

      let pctText;
      if (decimals <= 1 && rawPct >= near100Threshold && rawPct < 100) {
        // matches your preference:
        // decimals=0 => over 99.5%
        // decimals=1 => over 99.95%
        pctText = `over ${near100Threshold.toFixed(decimals === 0 ? 1 : 2)}%`;
      } else {
        pctText = displayedPct.toFixed(decimals) + "%";
      }

      let text =
        `${seasonName.charAt(0).toUpperCase() + seasonName.slice(1)} is ${pctText} complete (UTC).`;

      if (displayedPct >= 99.99 && nowUTC < endUTC) {
        const remaining = Math.max(0, Math.floor(endUTC.diff(nowUTC, "seconds").seconds));
        const mm = Math.floor(remaining / 60);
        const ss = String(remaining % 60).padStart(2, "0");
        text += `  ‚è≥ ${mm}:${ss} remaining`;
      }

      div.textContent = text;
    }

    function showSeasonTimes(bounds) {
      const { startUTC, endUTC, startLabel, endLabel } = bounds;
      const timesDiv = document.getElementById("seasonTimes");

      const z = getUserFixedZone();
      const displayZone = z ? z.zone : "utc";
      const zoneLabel = z ? zonePrettyLabel(z.mins) : "UTC";

      const startStr = startUTC.setZone(displayZone).toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;
      const endStr = endUTC.setZone(displayZone).toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;

      timesDiv.innerHTML = `
        ${startLabel}: <strong>${startStr}</strong><br>
        ${endLabel}: <strong>${endStr}</strong>
      `;
    }

    // ===== Countdown formatter (used in milestone section) =====
    function formatCountdown(totalSeconds) {
      const s = Math.max(0, Math.floor(totalSeconds));
      const days = Math.floor(s / 86400);
      const rem = s % 86400;
      const hh = Math.floor(rem / 3600).toString().padStart(2, "0");
      const mm = Math.floor((rem % 3600) / 60).toString().padStart(2, "0");
      const ss = Math.floor(rem % 60).toString().padStart(2, "0");
      return `${days}d ${hh}:${mm}:${ss}`;
    }

    // ===== Milestones + elapsed + countdown (fixed to avoid off-by-one) =====
    function showMilestoneTimes(bounds) {
      const milestoneDiv = document.getElementById("milestones");
      const { startUTC, endUTC } = bounds;
      const nowUTC = DateTime.utc();

      // Use integer milliseconds for consistent elapsed/remaining/total display
      const startMs = startUTC.toMillis();
      const endMs = endUTC.toMillis();
      const nowMs = nowUTC.toMillis();

      const totalMs = endMs - startMs;
      const elapsedMs = Math.max(0, Math.min(totalMs, nowMs - startMs));

      const totalSecondsInt = Math.floor(totalMs / 1000);
      const elapsedSecondsInt = Math.floor(elapsedMs / 1000);
      const remainingSecondsInt = Math.max(0, totalSecondsInt - elapsedSecondsInt);

      const z = getUserFixedZone();
      const displayZone = z ? z.zone : "utc";
      const zoneLabel = z ? zonePrettyLabel(z.mins) : "UTC";

      let html =
        `<p><strong>${elapsedSecondsInt.toLocaleString()}</strong> seconds have passed out of ` +
        `<strong>${totalSecondsInt.toLocaleString()}</strong>.</p>`;

      // Countdown goes directly under the seconds-count-up line
      html += `<p><strong>Countdown:</strong> ${formatCountdown(remainingSecondsInt)}</p>`;

      // Milestone heading above the list
      html += `<h3>Milestone Dates (shown in ${zoneLabel}):</h3>`;
      html += `<ul>`;

      // Milestones computed from the same totalMs interval (consistent with rounding and display)
      for (const m of milestones) {
        const milestoneMsOffset = totalMs * m.value;
        const milestoneDT = DateTime.fromMillis(startMs + milestoneMsOffset, { zone: "utc" }).setZone(displayZone);
        const label = milestoneDT.toFormat("EEE, MMM d, yyyy, HH:mm:ss") + ` ${zoneLabel}`;
        html += `<li>${m.label} complete: <strong>${label}</strong></li>`;
      }

      html += `</ul>`;
      milestoneDiv.innerHTML = html;
    }

    function updateCurrentTime() {
      const currentDiv = document.getElementById("currentTime");
      const z = getUserFixedZone();

      const nowInUserZone = z ? DateTime.now().setZone(z.zone) : DateTime.now();
      const nowUTC = DateTime.utc();

      const userLabel = z
        ? zonePrettyLabel(z.mins)
        : (nowInUserZone.offset === 0 ? "UTC" : `UTC${minutesToSignedHHMM(nowInUserZone.offset)}`);

      currentDiv.textContent =
        `‚è± Current time (your entered offset): ${nowInUserZone.toFormat("EEE, MMM d, yyyy, HH:mm:ss")} (${userLabel})  |  ` +
        `UTC now: ${nowUTC.toFormat("EEE, MMM d, yyyy, HH:mm:ss 'UTC'")}`;
    }

    function updateAll() {
      const hemiChoice = (localStorage.getItem(HEMI_KEY) || "auto");
      const hemi = hemiChoice === "auto" ? getHemisphere() : hemiChoice;

      const nowUTC = DateTime.utc();
      const bounds = currentSeasonBounds(nowUTC, hemi);

      updateSeasonHeading(bounds);
      showSeasonTimes(bounds);
      showMilestoneTimes(bounds);
      updateSeasonProgress(bounds);
      updateCurrentTime();
    }

    (function initControls() {
      // Hemisphere selector
      const savedHemi = localStorage.getItem(HEMI_KEY) || "auto";
      hemiSelect.value = savedHemi;
      hemiSelect.addEventListener("change", () => {
        localStorage.setItem(HEMI_KEY, hemiSelect.value);
        updateAll();
      });

      // UTC offset
      const savedOffset = localStorage.getItem(OFFSET_KEY);
      if (savedOffset) offsetInput.value = savedOffset;
      const z = getUserFixedZone();
      setUserOffsetDisplay(z ? z.mins : null);

      // Percent mode + decimals
      const savedMode = localStorage.getItem(PCT_MODE_KEY) || "truncate";
      pctModeSelect.value = savedMode;

      const savedDec = localStorage.getItem(PCT_DECIMALS_KEY);
      pctDecimalsSelect.value = (savedDec != null) ? savedDec : "2";

      pctModeSelect.addEventListener("change", () => {
        localStorage.setItem(PCT_MODE_KEY, pctModeSelect.value);
        updateAll();
      });

      pctDecimalsSelect.addEventListener("change", () => {
        localStorage.setItem(PCT_DECIMALS_KEY, pctDecimalsSelect.value);
        updateAll();
      });
    })();

    updateAll();
    setInterval(updateAll, 1000);
  </script>
</body>
</html>
