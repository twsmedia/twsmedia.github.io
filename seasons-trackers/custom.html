<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Custom Season Tracker (Fixed UTC Offset)</title>
  <script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; line-height: 1.5; font-size: 18px; margin: 0; }
    h2 { margin: 0 0 8px; }
    .note { color:#555; margin-bottom: 12px; font-size: 14px; }
    .row { display:flex; flex-wrap: wrap; gap: 12px; align-items: center; margin: 10px 0; }
    label { font-size: 16px; }
    input[type="text"], input[type="datetime-local"], button, select { font-size: 16px; padding: 6px 8px; }
    #seasonProgress { margin: 10px 0; }
    #seasonTimes { margin: 8px 0 14px; }
    #milestones { font-size: 16px; margin-bottom: 16px; }
    .divider { height: 1px; background: #e4e4e4; margin: 18px 0; }
    .preset-section { background: #f0f8ff; padding: 12px; border-radius: 4px; margin: 10px 0; }
    .preset-buttons { display: flex; gap: 8px; margin: 8px 0; flex-wrap: wrap; }
    .preset-btn { background: #4CAF50; color: white; border: none; padding: 8px 12px; border-radius: 4px; cursor: pointer; }
    .preset-btn:hover { background: #45a049; }
    .save-preset { background: #2196F3; }
    .save-preset:hover { background: #1976D2; }
    .delete-preset { background: #f44336; }
    .delete-preset:hover { background: #d32f2f; }
    input[type="text"].preset-name { width: 200px; }

    /* NEW: small helper style */
    .inline { display: inline-flex; align-items: center; gap: 10px; }
  </style>
</head>
<body>
  <h2>Custom Season Tracker</h2>
  <div id="tzNote" class="note"></div>

  <!-- Preset Section -->
  <div class="preset-section">
    <strong>ðŸ”– Saved Presets:</strong>
    <div id="presetButtons" class="preset-buttons"></div>
    <div class="row" style="margin-top: 12px;">
      <input type="text" id="presetName" class="preset-name" placeholder="Enter preset name (e.g., 'Fall Reading')">
      <button id="savePresetBtn" class="preset-btn save-preset">Save Current Settings as Preset</button>
    </div>
    <div class="note">Save your current settings as a preset, then use the buttons above to quickly switch between different trackers.</div>
  </div>

  <!-- Settings -->
  <div class="row">
    <label for="seasonName">Label (optional):</label>
    <input id="seasonName" type="text" placeholder="e.g., 'Fall Reading Challenge'">
  </div>

  <div class="row">
    <label for="startDT">Start:</label>
    <input id="startDT" type="datetime-local" />
    <label for="endDT">End:</label>
    <input id="endDT" type="datetime-local" />
  </div>

  <div class="row">
    <label for="utcOffset">Custom UTC offset (no DST):</label>
    <input id="utcOffset" type="text" placeholder="Examples: 0, -5.5, +05:30">
    <button id="applyBtn">Apply / Save</button>
    <span id="offsetStatus" class="note"></span>
  </div>

  <div class="divider"></div>

  <!-- Output -->
  <div id="seasonHeading"></div>
  <div id="seasonProgress"></div>
  <div id="seasonTimes" class="note"></div>

  <!-- New: seconds + countdown directly under the seconds line -->
  <div id="secondsLine"></div>
  <div id="countdown" style="font-size:18px; font-weight:bold; margin-bottom:12px;"></div>

  <div id="milestones"></div>
  <div id="currentTime" class="note"></div>

  <div class="divider"></div>

  <!-- NEW: Bottom Display Options -->
  <div id="displayOptions">
    <h3>Display Options</h3>
    <div class="row">
      <label for="pctPlaces">Decimal places:</label>
      <select id="pctPlaces" title="How many places after the decimal to show">
        <option>0</option><option>1</option><option selected>2</option><option>3</option><option>4</option><option>5</option><option>6</option>
      </select>

      <span class="inline" role="group" aria-label="Rounding mode">
        <label><input type="radio" name="pctMode" value="round" checked> Round</label>
        <label><input type="radio" name="pctMode" value="truncate"> Truncate (floor)</label>
      </span>

      <span id="preview" class="note"></span>
    </div>
  </div>

  <script>
    (function () {
      const { DateTime, FixedOffsetZone } = luxon;

      function $(id){ return document.getElementById(id); }

      // --- Utilities for fixed offset handling (no DST) ---
      function minutesToSignedHHMM(mins){
        const sign = mins < 0 ? "-" : "+";
        const a = Math.abs(mins);
        const hh = String(Math.floor(a/60)).padStart(2,"0");
        const mm = String(a % 60).padStart(2,"0");
        return sign + hh + ":" + mm;
      }
      function zonePrettyLabel(mins){
        if (mins == null) return "UTC";
        const a = Math.abs(mins), sign = mins < 0 ? "-" : "+";
        const hh = Math.floor(a/60), mm = a % 60;
        return mm === 0 ? `UTC${sign}${hh}` : `UTC${minutesToSignedHHMM(mins)}`;
      }
      function parseOffsetToMinutes(s){
        if (!s) return null;
        s = s.trim();
        if (/^[+-]?\d+(\.\d+)?$/.test(s)) return Math.round(parseFloat(s)*60);
        const m = s.match(/^([+-])(\d{1,2}):([0-5]\d)$/);
        if (m){
          const sign = m[1] === "-" ? -1 : 1;
          const hh = parseInt(m[2],10), mm = parseInt(m[3],10);
          return sign*(hh*60+mm);
        }
        return null;
      }

      // --- Storage keys ---
      const LS = {
        NAME: "customSeason_name",
        START: "customSeason_start",
        END: "customSeason_end",
        OFFSET: "customSeason_offset",
        PRESETS: "customSeason_presets",
        // NEW
        PCT_PLACES: "customSeason_pctPlaces",
        PCT_MODE: "customSeason_pctMode"
      };

      // --- Preset management ---
      function getPresets() {
        const saved = localStorage.getItem(LS.PRESETS);
        return saved ? JSON.parse(saved) : {};
      }

      function savePresets(presets) {
        localStorage.setItem(LS.PRESETS, JSON.stringify(presets));
      }

      function saveCurrentAsPreset(name) {
        if (!name.trim()) {
          alert("Please enter a name for the preset.");
          return;
        }
        
        const presets = getPresets();
        presets[name] = {
          name: nameInput.value.trim(),
          start: startInput.value,
          end: endInput.value,
          offset: offsetInput.value.trim()
        };
        
        savePresets(presets);
        renderPresetButtons();
        $("presetName").value = "";
      }

      function loadPreset(presetName) {
        const presets = getPresets();
        const preset = presets[presetName];
        if (!preset) return;
        
        nameInput.value = preset.name || "";
        startInput.value = preset.start || "";
        endInput.value = preset.end || "";
        offsetInput.value = preset.offset || "";
        
        // Also apply the settings
        applySettings();
      }

      function deletePreset(presetName) {
        if (!confirm(`Delete preset "${presetName}"?`)) return;
        
        const presets = getPresets();
        delete presets[presetName];
        savePresets(presets);
        renderPresetButtons();
      }

      function renderPresetButtons() {
        const container = $("presetButtons");
        const presets = getPresets();
        
        container.innerHTML = "";
        
        if (Object.keys(presets).length === 0) {
          container.innerHTML = '<div class="note">No saved presets yet. Save your first preset below!</div>';
          return;
        }
        
        for (const [name, preset] of Object.entries(presets)) {
          const btn = document.createElement("button");
          btn.className = "preset-btn";
          btn.textContent = name;
          btn.onclick = () => loadPreset(name);
          container.appendChild(btn);
          
          const deleteBtn = document.createElement("button");
          deleteBtn.className = "preset-btn delete-preset";
          deleteBtn.textContent = "Ã—";
          deleteBtn.title = `Delete "${name}"`;
          deleteBtn.onclick = (e) => {
            e.stopPropagation();
            deletePreset(name);
          };
          container.appendChild(deleteBtn);
        }
      }

      // --- Milestones ---
      const milestones = [
        { label: "10%", value: 0.10 },
        { label: "20%", value: 0.20 },
        { label: "25%", value: 0.25 },
        { label: "30%", value: 0.30 },
        { label: "â…“",  value: 1/3   },
        { label: "40%", value: 0.40 },
        { label: "50%", value: 0.50 },
        { label: "60%", value: 0.60 },
        { label: "â…”",  value: 2/3   },
        { label: "70%", value: 0.70 },
        { label: "75%", value: 0.75 },
        { label: "80%", value: 0.80 },
        { label: "90%", value: 0.90 }
      ];

      // --- Elements ---
      const nameInput = $("seasonName");
      const startInput = $("startDT");
      const endInput = $("endDT");
      const offsetInput = $("utcOffset");
      const applyBtn = $("applyBtn");
      const presetNameInput = $("presetName");
      const savePresetBtn = $("savePresetBtn");

      // NEW: bottom controls
      const pctPlacesSel = $("pctPlaces");
      const pctModeRadios = () => [...document.querySelectorAll('input[name="pctMode"]')];
      const preview = $("preview");

      // Dynamic display elements
      const secondsLineEl = $("secondsLine");
      const countdownEl = $("countdown");
      const milestonesEl = $("milestones");
      const seasonHeadingEl = $("seasonHeading");
      const seasonProgressEl = $("seasonProgress");
      const seasonTimesEl = $("seasonTimes");
      const currentTimeEl = $("currentTime");

      // Cached static state
      let cachedZone = FixedOffsetZone.utcInstance;
      let cachedLabel = "UTC";
      let cachedStartDT = null;
      let cachedEndDT = null;
      let cachedTotalSeconds = 0;

      // --- Load values from localStorage ---
      function loadFromLocalStorage(){
        const name = localStorage.getItem(LS.NAME) || "";
        const startV = localStorage.getItem(LS.START) || "";
        const endV = localStorage.getItem(LS.END) || "";
        const off = localStorage.getItem(LS.OFFSET) || "";

        // NEW: places/mode
        const places = localStorage.getItem(LS.PCT_PLACES);
        const mode = localStorage.getItem(LS.PCT_MODE);

        nameInput.value = name;
        startInput.value = startV;
        endInput.value = endV;
        offsetInput.value = off;

        if (places !== null) pctPlacesSel.value = String(places);
        if (mode) {
          const radio = pctModeRadios().find(r => r.value === mode);
          if (radio) radio.checked = true;
        }
      }

      // --- Zone helpers ---
      function getUserFixedZone(){
        const saved = localStorage.getItem(LS.OFFSET);
        const mins = parseOffsetToMinutes(saved);
        if (mins === null) return { zone: FixedOffsetZone.utcInstance, mins: 0, label: "UTC" };
        return { zone: FixedOffsetZone.instance(mins), mins, label: zonePrettyLabel(mins) };
      }
      function setOffsetStatus(){
        const saved = localStorage.getItem(LS.OFFSET);
        const mins = parseOffsetToMinutes(saved);
        $("offsetStatus").textContent = mins === null
          ? " (Times show in UTC by default; enter an offset to change.)"
          : " (" + zonePrettyLabel(mins) + ")";
      }

      // --- Parse datetime-local input into Luxon DT in the chosen fixed zone ---
      function parseLocalInputToZoneDT(value, zone){
        if (!value) return null;
        const m = value.match(/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2})(?::(\d{2}))?$/);
        if (!m) return null;
        const [ , Y, Mo, D, H, Mi, S ] = m;
        return DateTime.fromObject(
          {
            year: +Y, month: +Mo, day: +D,
            hour: +H, minute: +Mi, second: S ? +S : 0, millisecond: 0
          },
          { zone }
        );
      }

      // NEW: percent formatter (round vs truncate)
      function formatPercent(pct, places, mode){
        // Clamp to [0,100] for display safety
        const val = Math.min(100, Math.max(0, pct));
        const factor = 10 ** places;

        let out;
        if (mode === "truncate") {
          // floor at the specified precision
          out = Math.trunc(val * factor) / factor;
        } else {
          // default: round
          out = Math.round(val * factor) / factor;
        }
        // Always show fixed decimals per user choice
        return out.toFixed(places) + "%";
      }

      // NEW: adaptive near-100% message threshold
      function nearHundredMessage(places){
        const threshold = 100 - 1 / (10 ** places); // e.g., places=2 => 99.99
        return `greater than ${threshold.toFixed(places)}% complete.`;
      }

      // Helper: get current percent display settings
      function getPercentPrefs() {
        const places = parseInt(localStorage.getItem(LS.PCT_PLACES) ?? pctPlacesSel.value, 10) || 0;
        const mode = localStorage.getItem(LS.PCT_MODE) || (pctModeRadios().find(r => r.checked) || {value:"round"}).value;
        return { places, mode };
      }

      function updatePreview() {
        const { places, mode } = getPercentPrefs();
        const demoIn = 89.999;
        preview.textContent = `Preview: ${demoIn}% â†’ ${formatPercent(demoIn, places, mode)} (mode: ${mode}, places: ${places})`;
      }

      // --- Recompute static layout (no per-second stuff here) ---
      function recomputeStatic() {
        const zInfo = getUserFixedZone();
        cachedZone = zInfo.zone;
        cachedLabel = zInfo.label;

        $("tzNote").textContent = `This tracker uses a fixed offset: ${cachedLabel} (ignores DST).`;

        const nm = nameInput.value.trim();
        const headingName = nm ? nm : "Custom Season";
        seasonHeadingEl.innerHTML = `<strong>${headingName}</strong>`;

        const startDT = parseLocalInputToZoneDT(startInput.value, cachedZone);
        const endDT   = parseLocalInputToZoneDT(endInput.value, cachedZone);

        // Reset cached state by default
        cachedStartDT = null;
        cachedEndDT = null;
        cachedTotalSeconds = 0;

        const fmt = "EEE, MMM d, yyyy, HH:mm:ss";

        if (!startDT || !endDT){
          seasonTimesEl.textContent = "";
          milestonesEl.innerHTML = "";
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          seasonProgressEl.textContent = "Enter a valid start and end date-time, then press Apply / Save.";
          return;
        }

        if (endDT <= startDT){
          seasonTimesEl.textContent = "";
          milestonesEl.innerHTML = "";
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          seasonProgressEl.textContent = "End must be after Start.";
          return;
        }

        // Valid range â€“ cache and render static bits
        cachedStartDT = startDT;
        cachedEndDT = endDT;
        cachedTotalSeconds = endDT.diff(startDT).as("seconds");

        seasonTimesEl.innerHTML =
          `Start: <strong>${startDT.toFormat(fmt)} ${cachedLabel}</strong><br>` +
          `End: <strong>${endDT.toFormat(fmt)} ${cachedLabel}</strong>`;

        // Build milestone list ONCE (static)
        let html = `<h3>Milestone Dates (${cachedLabel}):</h3><ul>`;
        for (const m of milestones){
          const dt = startDT.plus({ seconds: cachedTotalSeconds * m.value });
          html += `<li>${m.label} complete: <strong>${dt.toFormat(fmt)} ${cachedLabel}</strong></li>`;
        }
        html += `</ul>`;
        milestonesEl.innerHTML = html;
      }

      // --- Apply settings (save to localStorage and recompute static) ---
      function applySettings() {
        const val = offsetInput.value.trim();
        const mins = parseOffsetToMinutes(val);
        if (val !== "" && mins === null) {
          alert("Please enter a valid UTC offset (e.g., 0, 1, -5.5, +05:30), or leave blank for UTC.");
          return;
        }
        
        // Save to localStorage
        localStorage.setItem(LS.NAME, nameInput.value.trim());
        localStorage.setItem(LS.START, startInput.value);
        localStorage.setItem(LS.END, endInput.value);
        localStorage.setItem(LS.OFFSET, val);

        // Also persist display options
        const { places, mode } = getPercentPrefs();
        localStorage.setItem(LS.PCT_PLACES, String(places));
        localStorage.setItem(LS.PCT_MODE, mode);
        
        setOffsetStatus();
        recomputeStatic();
        updatePreview();
        tick(); // refresh dynamic bits immediately
      }

      // --- Dynamic per-second update (NO heavy DOM rebuilding) ---
      function formatCountdown(seconds) {
        if (seconds < 0) seconds = 0;
        const days = Math.floor(seconds / 86400);
        const hrs = Math.floor((seconds % 86400) / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        if (days >= 1) {
          return `${days}d ${hrs.toString().padStart(2,'0')}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
        } else {
          const totalHrs = Math.floor(seconds / 3600);
          return `${totalHrs}:${mins.toString().padStart(2,'0')}:${secs.toString().padStart(2,'0')}`;
        }
      }

      function tick() {
        updatePreview(); // keep preview consistent with any changed controls

        if (!cachedStartDT || !cachedEndDT || cachedTotalSeconds <= 0) {
          // Nothing to animate yet
          secondsLineEl.textContent = "";
          countdownEl.textContent = "";
          currentTimeEl.textContent = "";
          return;
        }

        const { places, mode } = getPercentPrefs();
        const now = DateTime.now().setZone(cachedZone);

        const totalSeconds = cachedTotalSeconds;
        const elapsedSeconds = now.diff(cachedStartDT).as("seconds");
        const clampedElapsed = Math.max(0, Math.min(totalSeconds, elapsedSeconds));
        const pct = Math.max(0, Math.min(100, (clampedElapsed/totalSeconds)*100));

        let progressText = "";
        if (now < cachedStartDT){
          progressText = "This season hasn't started yet.";
        } else if (now >= cachedEndDT){
          progressText = `This season has ended (${formatPercent(100, places, mode)} complete).`;
        } else {
          const nearThreshold = 100 - 1 / (10 ** places); // e.g., 99.99 when places=2
          if (pct >= nearThreshold && pct < 100) {
            progressText = `This season is ${nearHundredMessage(places)}`;
          } else {
            progressText = `This season is ${formatPercent(pct, places, mode)} complete.`;
          }
        }
        seasonProgressEl.textContent = progressText;

        // Seconds line
        secondsLineEl.textContent =
          `${Math.floor(clampedElapsed).toLocaleString()} seconds have passed out of ${Math.floor(totalSeconds).toLocaleString()}.`;

        // Current time
        const fmt = "EEE, MMM d, yyyy, HH:mm:ss";
        currentTimeEl.textContent = `â± Current time: ${now.toFormat(fmt)} (${cachedLabel})`;

        // Countdown
        const remaining = cachedEndDT.diff(now, "seconds").seconds;
        if (remaining <= 0) {
          countdownEl.textContent = "â³ Countdown: 00:00:00 (season ended)";
        } else {
          countdownEl.textContent = "â³ Countdown: " + formatCountdown(remaining);
        }
      }

      // --- Event handlers ---
      applyBtn.addEventListener("click", applySettings);

      savePresetBtn.addEventListener("click", () => {
        saveCurrentAsPreset(presetNameInput.value.trim());
      });

      presetNameInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          saveCurrentAsPreset(presetNameInput.value.trim());
        }
      });

      // NEW: instantly persist/display when changing bottom controls
      $("pctPlaces").addEventListener("change", () => {
        localStorage.setItem(LS.PCT_PLACES, String(parseInt(pctPlacesSel.value,10)||0));
        updatePreview();
        tick();
      });
      pctModeRadios().forEach(r => r.addEventListener("change", () => {
        localStorage.setItem(LS.PCT_MODE, r.value);
        updatePreview();
        tick();
      }));

      // --- Init ---
      loadFromLocalStorage();
      setOffsetStatus();
      renderPresetButtons();
      recomputeStatic();
      updatePreview();
      tick();

      // Smooth per-second updates (no big DOM rebuilds)
      setInterval(tick, 1000);

    })();
  </script>
</body>
</html>
